\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=1.50cm, right=1.50cm, top=1.50cm, bottom=1.50cm]{geometry}

\usepackage{listings}
\usepackage{color,pdfcolmk}
\usepackage{url}
\usepackage{cleveref}

\newcommand{\g}{\texttt{g\"{u}nther}}
\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}


\begin{document}


\title{HOWTO g\"{u}nther with \g{}}

\maketitle

 
\g{} tests web applications against SSR. 

\section{Dependencies}

\begin{enumerate}
   \item Python 2.7

   \item install PyQt v 4. In ubuntu/debian* you can find it in the repo as 
   python-qt4. Otherwise you can use pip install but I don't remember the 
   package.

   \item httplib2. You should have it by default, not sure. In anycase, in ubuntu the
   packege is python-httplib2.

   \item cherrypy. Google it :)

   \item pyftpdlib. Google it :)

   \item install redis for python:
 
   $ pip install redis
   $ pip install hi-redis

   Redis is not essential. It is a high-performance nosql storage server to 
   store data. We may need it to handle all the data that we collect. I haven't 
   completed the integration of redis and the bit I did is not properly tested.

   \item ... 
\end{enumerate}

\section{Quick recap of SSR}

SSR is a communication pattern in which an intermediate server can retrieve an HTTP resource on behalf of a user. SSR can be vulnerable to a number of attacks. \textbf{The goal of \g{} is to test the intermediate SSR server to detect vulnerabilities that can be used to mount SSR-based attacks.}

We call $A$ the intermediate SSR server and $B$ the third-party server. The
attacker generates a message $m_A$ towards $A$. The message $m_A$ carries
another message $m_B$ for the target $B$. When $A$ interprets $m_A$, it will
generate the message $m_B$ and send it to $B$.

\section{Components}

\g{} has the following components:

\begin{description}

  \item[Tester] the goal of the tester is to probe $A$ with a number of messages
  which are meant for $B$ (a server under control of the tester). In each test,
  the tester prepares a message $m_A$ which will contain the message $m_B$
  (i.e., a URL). The structure of $m_A$ and the position of $m_B$ in $m_A$ is
  specified via the \g{} input file.

  \item[Monitor] is a server under control of the tester which hosts a number
  services to support the testing activity. The main services are the
  \emph{detection service} and the \emph{HTTP redirector}. The detection service
  plays the role of $B$. It waits for message $m_B$ generated by $A$ to confirm
  the presence of the vulnerability in $A$. The HTTP redirector service is used
  to test against input filtering bypass when $A$ accepts $m_A$. When the
  redirector is used, the tester generates a $m_A$ which does not contain $m_B$.
  Instead, it will contain a message $m_r$ for the redirection service.
  Afterwards, when the redirector receives $m_r$, it will redirect $A$ with an
  HTTP redirection message towards the detection service. In this case, the
  message $m_B$ is included in the HTTP redirection response.
  
  The monitor hosts other services. For example, an FTP daemon, a TCP server,
  and a web service to test the JS capabilities of user agents.

\end{description}




\section{Tutorial}

\subsection{Simple test}

In this example, we will test a web application $A$ to check whether it supports
the generation of HTTP request towards a target $B$. This example will not show
the generation of the $m_A$ for \g{} but we will assume that the format of $m_A$
is stored in \textbf{webapp\_A.json}. The generation of input file is described
in \Cref{sec:file_format}. This example will show the usage of \g{} via command
line.

\begin{verbatim}
$ guenther.py webapp_A.json -tD -l monitor.foo.com
\end{verbatim}

\textbf{-tD} will perform a test in which the URL to be sent to $A$ contains the
FQDN of the detection service. The parameter \textbf{-l} can be a hostname or an IP that the monitor will listen to for incoming messages. In case \g{} is executed from a local network behind a NAT/MASQUERADE, use the following parameters:

\begin{verbatim}
$ guenther.py webapp_A.json -tD -l 10.0.0.1 -p monitor.foo.com
\end{verbatim}

where 10.0.0.1 is the local IP and \textbf{monitor.foo.com} is the public IP of
the gateway. This example will work if there are in place port forwarding rules
between 10.0.0.1 and \textbf{monitor.foo.com}. Both \textbf{-p} and \textbf{-l}
accept IPs and hostnames.

\subsection{Bypassing FDQN only filters}

Now, let's assume that $A$ accepts only messages via FDQN. This can be
discovered with the previous command plus the following command:

\begin{verbatim}
$ guenther.py webapp_A.json -tI -l monitor.foo.com
\end{verbatim}

The output of this command will show that no message from $A$ has been received
by the detection service. However, it is still possible to bypass this filter
with the aid of the HTTP redirector:

\begin{verbatim}
$ guenther.py webapp_A.json -tI -tRx -l monitor.foo.com
\end{verbatim}

The parameter \textbf{-tRx} will change the behavior of \textbf{-tI} in which
the URL with the IP of the detection service is sent via redirection and not
directly.

The last two tests can be executed at once as follows:

\begin{verbatim}
$ guenther.py webapp_A.json -tI -tR -l monitor.foo.com
\end{verbatim}

As opposed to \textbf{-tRx}, \textbf{-tR} performs two tests: with and without
HTTP redirection.



\section{\g{} Input File Format}
\label{sec:file_format}

$m_A$ ise specified via an input file. The input file is a JSON
object that is provided via command line. The JSON input file is a dictionary
with the following keys \texttt{method}, \texttt{urlp}, \texttt{queryp},
\texttt{headers}, and \texttt{bodyp}. Below we show a general input file:

\lstset{basicstyle=\ttfamily,breaklines=true, frame=single, label={lst:gen1}, caption={\g{} input file format}}
\begin{lstlisting}[mathescape]
{
  "urlp"   : $s$,
  "queryp" : {
              $p_1$: $v_1$,
              $p_2$: $v_2$,
              ...
              $p_n: $v_n,
               }, 
  "headers": {
              $hn_1$: $hv_1$,
              $hn_2$: $hv_2$,
              ...
              $hn_n: $hv_n,
             }, 
  "bodyp"  : {
              $p'_1$: $v'_1$,
              $p'_2$: $v'_2$,
              ...
              $p'_n: $v'_n,
             }, 
  "method" : $m$
}
\end{lstlisting}

\begin{description}
   
   \item[method] (mandatory) is a string $s$ for the HTTP request method
   name, i.e., \texttt{"GET"}, \texttt{"POST"}.
   
   \item[urlp] (mandatory) is string which contains an URL without query string.
   \texttt{urlp} identifies the endpoint of $A$ including the URL path.
   
   \item[queryp] (optional) is a dictionary which maps a URL parameter $p_i$
   with a value $v_i$ where $i=1, ..., n$. Values $v_i$ can be string data
   values, e.g., \texttt{"3"}, \texttt{"True"}, or \emph{placeholders}. \g{}
   supports only the placeholder string \texttt{"\{monitor\}"} that is replaced
   at runtime either with the URL of the detection service or with the URL of
   the redirection service. The tester transform \texttt{queryp} into a string
   $qs$ as follows. First, it replaces the placeholders with the URL according
   to the type of test. Then, the list of pairs $(p_1, v_1)$, $(p_2, v_2)$ is
   encoded as $p_1=\mathtt{urlencode}(v_1)\&p_2=\mathtt{urlencode}(v_2)$ where
   \texttt{urlencode} is the URL encoding algorithm. The string $qs$ is then
   concatenated with \texttt{urlp} as follows: \texttt{urlp} + \texttt{?} +
   $qs$.

   \item[headers] (optional) is a dictionary which maps header names $hn _i$, e.g.,
   \texttt{User-Agent}, with header values $hv_i$, e.g., \texttt{Mozilla/5.0
   (X11; Ubuntu; Linux x86\_64; rv:33.0) Gecko/20100101}.
   
   \item[bodyp] (optional) is a dictionary as sees for  \texttt{queryp}. The
   processing rules of \texttt{bodyp} are the same of \texttt{queryp}.

\end{description}

\subsection*{Escape Characters for JSON data values}

If \texttt{bodyp} or \texttt{queryp} contains a JSON string, please escape the character "\texttt{\{}" with the sequence "\texttt{\{\{}" and "\texttt{\}}" with "\texttt{\}\}}". Escaping MUST NOT be done for the placeholders.

\subsection{Example 1: A (generic) Vulnerable Web Application} 

This example is available in our repository in \texttt{example/gnt\_example\_POST.json}

In this example, the web application under test is available at the URL
\texttt{http://localhost:8080/}. $A$ accepts in input user-provided URL via an
HTTP form. The user browser submits a user-provider URL
\texttt{http://monitor.guenter.corp/} to $A$ with the following POST request:

\lstset{basicstyle=\ttfamily,breaklines=true, frame=single, label={lst:raw1}, caption={Raw HTTP Request}}
\begin{lstlisting}
POST /send HTTP/1.1\r\n
Host: localhost:8080\r\n
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n
Accept-Language: en-US,en;q=0.5\r\n
Accept-Encoding: gzip, deflate\r\n
Referer: http://localhost:8080/\r\n
Connection: keep-alive\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Content-Length: 23\r\n
\r\n
your_url=http://monitor.guenter.corp/\r\n
\end{lstlisting}

The above HTTP request is transformed into the below JSON object:

\lstset{basicstyle=\ttfamily,breaklines=true, frame=single, label={lst:fmtraw1}, caption={\g{} input file of the raw HTTP request}}
\begin{lstlisting}
{
  "urlp"   : "http://localhost:8080/send",
  "headers": {
              "Content-Type": "application/x-www-form-urlencoded"
             }, 
  "queryp" : {}, 
  "bodyp"  : {
               "your_url": "{monitor}"
             }, 
  "method" : "POST"
}
\end{lstlisting}

 \begin{description}
 
   \item[urlp] is the string \texttt{http://localhost:8080/send}. This is the
   combination of the header \texttt{Host} and the path of the resource
   requested \texttt{/send}
   
   \item[headers] contains only the \texttt{Content-Type} key. This header is
   used in order to allow $A$ to properly process the incoming request. Whether
   this field is necessary or not depends on the checks done on the server-side.
   The presence of these checks is out of the scope of \g{} and the user of \g{}
   needs to verify this on her own. The same consideration applies for other
   headers such as cookies.
 
   \item[queryp] is empty because there are no query strings in the URL
   requested.
   
   \item[bodyp] is a dictionary with only one entry: \texttt{your\_url} which is
   the parameter that contains the user-provided URL. Upon receiving this
   request, $A$ will use this parameter to identify the resource to be fetched.
   The value associated to \texttt{your\_url} is the placeholder
   \texttt{\{monitor\}}. The placeholder is replaced by \g{} at run-time
   depending on the type of tests to be performed.
   
 
 \end{description}

\subsection{Example 2: HTTP Validation by W3C}

This example is available in our repository in
\url{example/gnt\_validatew3.json}. Please note that W3C is not longer vulnerable and this test may no longer work.

W3C offers an online HTTP document validation service. This service is available
at \url{http://alidator.w3.org}. The W3 validator contains an HTTP GET form by
which the user can provide the URL of her own HTTP document. This is an example
of raw HTTP GET request that a browser would issue upon the submission of the
input \texttt{http://monitor.guenter.corp/}:

\lstset{basicstyle=\ttfamily,breaklines=true, frame=single, label={lst:raw2}, caption={Raw HTTP Request}}
\begin{lstlisting}
GET /check?uri=http%3A%2F%2Fmonitor.guenter.corp%2F&charset=%28detect %20automatically%29&doctype=Inline&group=0 HTTP/1.1\r\n
Host: validator.w3.org\r\n
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n
Accept-Language: en-US,en;q=0.5\r\n
Accept-Encoding: gzip, deflate\r\n
Referer: http://validator.w3.org/\r\n
Connection: keep-alive\r\n
\r\n
\end{lstlisting}

\lstset{basicstyle=\ttfamily,breaklines=true, frame=single, label={lst:fmtraw2}, caption={\g{} input file of the raw HTTP request}}
\begin{lstlisting}
{
  "method" : "GET",
  "urlp"   : "http://validator.w3.org/check"
  "queryp" : {
               "uri"    : "{monitor}",
               "charset": "(detect automatically)",
               "doctype": "Inline",
               "group"  : "0"
            },
  "headers": { 
               "User-Agent"     : "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:32.0) Gecko/20100101 Firefox/32.0",
               "Accept"         : "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
               "Accept-Language": "en-US,en;q=0.5",
               "Referer"        : "http://validator.w3.org/"
               }
}
\end{lstlisting}

\section{Usage}

Please refer to \texttt{--help}

\begin{verbatim}
Usage:

positional arguments:
  infile                file name of the HTTP request data in Guenther/JSON
                        format [default: stdin]

optional arguments:
  -h, --help            show this help message and exit
  -tD                   Basic test. It tests if the application accepts URL
                        with FQDN, e.g., http://localhost/
  -tI                   Basic test. It tests if the application accepts URL
                        with an IP address, e.g., http://127.0.0.1/
  -tR                   It uses HTTP redirection to test the application
                        against input validation bypass. This option executes
                        the selected basic tests twice: with and without HTTP
                        302 redirection.
  -tRx                  It changes the behavior of basic tests by using HTTP
                        302 redirections.
  -tPOST                Basic test. It tests if the application accepts POST
                        requests. This option forces the use of POST.
  -tJS                  Basic tests. It tests for JS capabilities of the HTTP
                        agent. It performs three tests (i) the presence of
                        XMLHTTPRequest API, (ii) the presence of Image, and
                        (iii) the duration time in multiple of 250
                        milliseconds.
  -w WAIT, --wait WAIT  wait time in seconds before shutting down the monitors
                        [default: 5]
  -d DELAY, --delay DELAY
                        time interval between two consecutive tests [default:
                        2]
  --timeout TIMEOUT     TCP timeout [default: 30]
  -v, --verbose         set verbosity level [default: None]
  -b BIND, --bind BIND  host of the monitor [default: localhost]
  --public PUBLIC       public IP or FQDN to be used in the injected URL. To
                        be used in case the monitor is behind a router.
                        [default: localhost]
  -V, --version         show program's version number and exit
  -O OUTPUT_FOLDER, --output OUTPUT_FOLDER
                        output folders where to store JSON output data

Non-standard HTTP port test options:
  -tP                   Basic test. It tests if the application accepts an URL
                        with (i) http scheme, (ii) FQDN , and (iii) a non-
                        standard HTTP port. For the default port, see --tP-
                        port
  --tP-port TP_PORT     custom TCP port for -tP. [default= 8099]

URL scheme test options:
  -tS                   Basic test. It tests if the application accepts an URL
                        with a non-HTTP scheme, i.e., ftp://localhost/
  --tS-scheme TS_SCHEME
                        custom URL scheme. Supported schemes ftp, http,
                        gopher, dict, https, ldap [default: ftp]
  --tS-port TS_PORT     custom TCP port for -tS. [default=default port of
                        --tS-scheme]

HTTP Compression payload options:
  -tComprReq            Basic test. It tests if the application accepts
                        compressed request body. This option forces the use of
                        POST.
  --tComprReq-ignore-body
                        Ignore the 'bodyp' field of the request
  --tComprReq-layers COMPR_LAYERS
                        the number of compression layers. This changes the
                        Content-Encoding value, e.g., with 3 the content
                        encoding header will be 'Content-Encoding: gzip, gzip,
                        gzip' [default: 1]
\end{verbatim}

\section{FAQ}

\begin{description}

   \item[Q1] What should I doublecheck in my JSON file?

   \item[A1] The following things:

   \begin{itemize}

      \item \texttt{queryp} and \texttt{bodyp} must be URL decoded. This is
      necessary because \g{} will use URL encode to generate requests. If
      \texttt{queryp} and \texttt{bodyp} are already URL encoded, they will be
      encoded a second time resulting in a potentially invalid HTTP request.

	  \item if \textbf{\{monitor\}} is in the query string, then create a
	  \textbf{queryp}. If not, you can leave the query string URL encoded inside
	  \textbraceleft{urlp}. In this case, no need to URL decode the query string.
	  
   \end{itemize}

   \item[Q2] I have a "\emph{Unknown host}" error.
   
   \item[A2] If the parameter of \textbf{--public} or \textbf{--bind} is a
   public IP, make sure that can be reversed to a public FQDN. If the parameter
   is a FQDN, make sure that it is resolved to a public IP.

   \item[Q3] I am not sure if my machine is properly configured for \g{}. What
   can I do to check that?
   
  \item[A3] Run \g{} by adding \textbf{--monitor-only}. Then from a browser
   connect to the following URL \textbf{http://yourpublicdomainname/detect/}.
   After that, go back to \g{} and press CTRL+C. If it worked, you will find in
   the section "HTTP Detection" the log of your connection.

\end{description}


\end{document}